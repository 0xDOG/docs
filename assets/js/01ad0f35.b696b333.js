(self.webpackChunkuniswap=self.webpackChunkuniswap||[]).push([[7328],{2410:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return c},default:function(){return u}});var o=n(2122),a=n(9756),i=(n(7294),n(3905)),r={id:"creating-a-pool",title:"Creating a Pool Instance"},l=void 0,s={unversionedId:"guides/creating-a-pool",id:"version-3.0.0/guides/creating-a-pool",isDocsHomePage:!1,title:"Creating a Pool Instance",description:'This guide extends the previous getting started guide by using the fetched data from the EVM to create a Pool instance using the V3 SDK. A "Pool" as we refer to it here does not mean an actual V3 pool, but a model of one created with the SDK. This model will help us interact with the protocol, or manipulate data relevant to the protocol, in a way that does not require continually fetching pool data from the EVM - which can be time intensive and computationally costly.',source:"@site/SDK_versioned_docs/version-3.0.0/guides/03-creating-a-pool.md",sourceDirName:"guides",slug:"/guides/creating-a-pool",permalink:"/sdk/guides/creating-a-pool",version:"3.0.0",sidebarPosition:3,frontMatter:{id:"creating-a-pool",title:"Creating a Pool Instance"},sidebar:"version-V3/sdksidebar",previous:{title:"Using Ethers.js",permalink:"/sdk/guides/using-ethers"},next:{title:"Minting a new Position",permalink:"/sdk/guides/liquidity/minting"}},c=[{value:"Importing the ABI",id:"importing-the-abi",children:[]},{value:"Creating The Interfaces",id:"creating-the-interfaces",children:[]},{value:"Fetching Immutable Data",id:"fetching-immutable-data",children:[]},{value:"Fetching State Data",id:"fetching-state-data",children:[]},{value:"Creating the Pool Instance",id:"creating-the-pool-instance",children:[]},{value:"The Final Script",id:"the-final-script",children:[]}],p={toc:c};function u(e){var t=e.components,n=(0,a.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This guide extends the previous ",(0,i.kt)("a",{parentName:"p",href:"./using-ethers"},"getting started")," guide by using the fetched data from the EVM to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pool"),' instance using the V3 SDK. A "Pool" as we refer to it here does not mean an actual V3 pool, but a model of one created with the SDK. This model will help us interact with the protocol, or manipulate data relevant to the protocol, in a way that does not require continually fetching pool data from the EVM - which can be time intensive and computationally costly.'),(0,i.kt)("h2",{id:"importing-the-abi"},"Importing the ABI"),(0,i.kt)("p",null,"First we will replace the abi that we previously wrote out manually with a library that contains the total V3 pool abi for us to easily interact with. Note the abi is imported from the ",(0,i.kt)("inlineCode",{parentName:"p"},"v3-core")," npm package, rather than the ",(0,i.kt)("inlineCode",{parentName:"p"},"v3-sdk")," npm package, as it is a part of the protocol rather than the SDK."),(0,i.kt)("p",null,"Depending on your local configuration, you may need to update your tsconfig.json to allow importing of ",(0,i.kt)("inlineCode",{parentName:"p"},"json")," files with ",(0,i.kt)("inlineCode",{parentName:"p"},'"resolveJsonModule": true,'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { ethers } from "ethers";\nimport { Pool } from "@uniswap/v3-sdk";\nimport { Token } from "@uniswap/sdk-core";\nimport { abi as IUniswapV3PoolABI } from "@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json";\n')),(0,i.kt)("p",null,"Now we'll update the ",(0,i.kt)("inlineCode",{parentName:"p"},"Contract")," object with our imported ABI - and keep the pool address and provider the same as the previous example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const provider = new ethers.providers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/<YOUR-ENDPOINT-HERE>"\n);\nconst poolAddress = "0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8";\nconst poolContract = new ethers.Contract(\n  poolAddress,\n  IUniswapV3PoolABI,\n  provider\n);\n')),(0,i.kt)("h2",{id:"creating-the-interfaces"},"Creating The Interfaces"),(0,i.kt)("p",null,"Create two interfaces with types that are appropriate for the data we need. We won't be using all of this data, but some extra data is fetched for context."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Immutables {\n  factory: string;\n  token0: string;\n  token1: string;\n  fee: number;\n  tickSpacing: number;\n  maxLiquidityPerTick: ethers.BigNumber;\n}\n\ninterface State {\n  liquidity: ethers.BigNumber;\n  sqrtPriceX96: ethers.BigNumber;\n  tick: number;\n  observationIndex: number;\n  observationCardinality: number;\n  observationCardinalityNext: number;\n  feeProtocol: number;\n  unlocked: boolean;\n}\n")),(0,i.kt)("h2",{id:"fetching-immutable-data"},"Fetching Immutable Data"),(0,i.kt)("p",null,"Fetch the immutable data from the deployed V3 pool contract and return it to create a model of the pool. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"async function getPoolImmutables() {\n  const [factory, token0, token1, fee, tickSpacing, maxLiquidityPerTick] =\n    await Promise.all([\n      poolContract.factory(),\n      poolContract.token0(),\n      poolContract.token1(),\n      poolContract.fee(),\n      poolContract.tickSpacing(),\n      poolContract.maxLiquidityPerTick(),\n    ]);\n\n  const immutables: Immutables = {\n    factory,\n    token0,\n    token1,\n    fee,\n    tickSpacing,\n    maxLiquidityPerTick,\n  };\n  return immutables;\n}\n")),(0,i.kt)("p",null,"Fetch the state data in with the same ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all")," style. This approach queries state data concurrently, rather than sequentially, to avoid out of sync data that may be returned if sequential queries are executed over the span of two blocks."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sqrtRatioX96"),", despite being named differently, are interchangeable values.")),(0,i.kt)("h2",{id:"fetching-state-data"},"Fetching State Data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"async function getPoolState() {\n  const [liquidity, slot] = await Promise.all([\n    poolContract.liquidity(),\n    poolContract.slot0(),\n  ]);\n\n  const PoolState: State = {\n    liquidity,\n    sqrtPriceX96: slot[0],\n    tick: slot[1],\n    observationIndex: slot[2],\n    observationCardinality: slot[3],\n    observationCardinalityNext: slot[4],\n    feeProtocol: slot[5],\n    unlocked: slot[6],\n  };\n\n  return PoolState;\n}\n")),(0,i.kt)("h2",{id:"creating-the-pool-instance"},"Creating the Pool Instance"),(0,i.kt)("p",null,"Create a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", which calls previously written functions, and uses the returned data to construct two ",(0,i.kt)("inlineCode",{parentName:"p"},"Ethers.js")," ",(0,i.kt)("inlineCode",{parentName:"p"},"Token")," instances and a V3 SDK ",(0,i.kt)("inlineCode",{parentName:"p"},"Pool")," instance."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The final constructor argument when creating a Pool, ",(0,i.kt)("inlineCode",{parentName:"p"},"ticks"),", is optional. ",(0,i.kt)("inlineCode",{parentName:"p"},"ticks")," takes all tick data, including the liquidity within, which can be used to model the result of a swap. Because this can add up to a lot of data fetched from the EVM, it is optional and may be left out when not needed. In this example, we have left it out.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'async function main() {\n  const [immutables, state] = await Promise.all([\n    getPoolImmutables(),\n    getPoolState(),\n  ]);\n\n  const TokenA = new Token(3, immutables.token0, 6, "USDC", "USD Coin");\n\n  const TokenB = new Token(3, immutables.token1, 18, "WETH", "Wrapped Ether");\n\n  const poolExample = new Pool(\n    TokenA,\n    TokenB,\n    immutables.fee,\n    state.sqrtPriceX96.toString(),\n    state.liquidity.toString(),\n    state.tick\n  );\n  console.log(poolExample);\n}\n\nmain();\n')),(0,i.kt)("p",null,"If everything is working, the script should return something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"Pool {\n  token0: Token {\n    chainId: 1,\n    decimals: 6,\n    symbol: 'USDC',\n    name: 'USD Coin',\n    isNative: false,\n    isToken: true,\n    address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'\n  },\n  token1: Token {\n    chainId: 1,\n    decimals: 18,\n    symbol: 'WETH',\n    name: 'Wrapped Ether',\n    isNative: false,\n    isToken: true,\n    address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'\n  },\n  fee: 3000,\n  sqrtRatioX96: JSBI(4) [ 1389262056, -1079304777, -1721588872, 19633, sign: false ],\n  liquidity: JSBI(3) [ 988036789, -62655684, 1, sign: false ],\n  tickCurrent: 197709,\n  tickDataProvider: NoTickDataProvider {}\n}\n")),(0,i.kt)("h2",{id:"the-final-script"},"The Final Script"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'import { ethers } from "ethers";\nimport { Pool } from "@uniswap/v3-sdk";\nimport { Token } from "@uniswap/sdk-core";\nimport { abi as IUniswapV3PoolABI } from "@uniswap/v3-core/artifacts/contracts/interfaces/IUniswapV3Pool.sol/IUniswapV3Pool.json";\n\nconst provider = new ethers.providers.JsonRpcProvider(\n  "https://mainnet.infura.io/v3/<YOUR-ENDPOINT-HERE>"\n);\n\n\nconst poolAddress = "0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8";\n\nconst poolContract = new ethers.Contract(\n  poolAddress,\n  IUniswapV3PoolABI,\n  provider\n);\n\ninterface Immutables {\n  factory: string;\n  token0: string;\n  token1: string;\n  fee: number;\n  tickSpacing: number;\n  maxLiquidityPerTick: ethers.BigNumber;\n}\n\ninterface State {\n  liquidity: ethers.BigNumber;\n  sqrtPriceX96: ethers.BigNumber;\n  tick: number;\n  observationIndex: number;\n  observationCardinality: number;\n  observationCardinalityNext: number;\n  feeProtocol: number;\n  unlocked: boolean;\n}\n\nasync function getPoolImmutables() {\n  const [factory, token0, token1, fee, tickSpacing, maxLiquidityPerTick] =\n    await Promise.all([\n      poolContract.factory(),\n      poolContract.token0(),\n      poolContract.token1(),\n      poolContract.fee(),\n      poolContract.tickSpacing(),\n      poolContract.maxLiquidityPerTick(),\n    ]);\n\n  const immutables: Immutables = {\n    factory,\n    token0,\n    token1,\n    fee,\n    tickSpacing,\n    maxLiquidityPerTick,\n  };\n  return immutables;\n}\n\nasync function getPoolState() {\n  const [liquidity, slot] = await Promise.all([\n    poolContract.liquidity(),\n    poolContract.slot0(),\n  ]);\n\n  const PoolState: State = {\n    liquidity,\n    sqrtPriceX96: slot[0],\n    tick: slot[1],\n    observationIndex: slot[2],\n    observationCardinality: slot[3],\n    observationCardinalityNext: slot[4],\n    feeProtocol: slot[5],\n    unlocked: slot[6],\n  };\n\n  return PoolState;\n}\n\nasync function main() {\n  const [immutables, state] = await Promise.all([\n    getPoolImmutables(),\n    getPoolState(),\n  ]);\n\n  const TokenA = new Token(3, immutables.token0, 6, "USDC", "USD Coin");\n\n  const TokenB = new Token(3, immutables.token1, 18, "WETH", "Wrapped Ether");\n\n  const poolExample = new Pool(\n    TokenA,\n    TokenB,\n    immutables.fee,\n    state.sqrtPriceX96.toString(),\n    state.liquidity.toString(),\n    state.tick\n  );\n  console.log(poolExample);\n}\n\nmain();\n\n')))}u.isMDXComponent=!0},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return m}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?o.createElement(h,r(r({ref:t},p),{},{components:n})):o.createElement(h,r({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);