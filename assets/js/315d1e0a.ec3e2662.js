(self.webpackChunkuniswap=self.webpackChunkuniswap||[]).push([[7254],{8567:function(t,e,n){"use strict";n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return u},default:function(){return m}});var r=n(2122),a=n(9756),i=(n(7294),n(3905)),o={},p=void 0,l={unversionedId:"reference/core/libraries/SwapMath",id:"version-V3/reference/core/libraries/SwapMath",isDocsHomePage:!1,title:"SwapMath",description:"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.",source:"@site/versioned_docs/version-V3/reference/core/libraries/SwapMath.md",sourceDirName:"reference/core/libraries",slug:"/reference/core/libraries/SwapMath",permalink:"/protocol/reference/core/libraries/SwapMath",editUrl:"https://github.com/uniswap/uniswap-docs/tree/main/versioned_docs/version-V3/reference/core/libraries/SwapMath.md",version:"V3",frontMatter:{},sidebar:"version-V3/mySidebar",previous:{title:"SqrtPriceMath",permalink:"/protocol/reference/core/libraries/SqrtPriceMath"},next:{title:"Tick",permalink:"/protocol/reference/core/libraries/Tick"}},u=[{value:"Functions",id:"functions",children:[{value:"computeSwapStep",id:"computeswapstep",children:[]}]}],c={toc:u};function m(t){var e=t.components,n=(0,a.Z)(t,["components"]);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick."),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("h3",{id:"computeswapstep"},"computeSwapStep"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-solidity"},"  function computeSwapStep(\n    uint160 sqrtRatioCurrentX96,\n    uint160 sqrtRatioTargetX96,\n    uint128 liquidity,\n    int256 amountRemaining,\n    uint24 feePips\n  ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount)\n")),(0,i.kt)("p",null,"Computes the result of swapping some amount in, or amount out, given the parameters of the swap"),(0,i.kt)("p",null,"The fee, plus the amount in, will never exceed the amount remaining if the swap's ",(0,i.kt)("inlineCode",{parentName:"p"},"amountSpecified")," is positive"),(0,i.kt)("h4",{id:"parameters"},"Parameters:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"sqrtRatioCurrentX96")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint160"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The current sqrt price of the pool")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"sqrtRatioTargetX96")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint160"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The price that cannot be exceeded, from which the direction of the swap is inferred")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"liquidity")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint128"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The usable liquidity")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"amountRemaining")),(0,i.kt)("td",{parentName:"tr",align:"left"},"int256"),(0,i.kt)("td",{parentName:"tr",align:"left"},"How much input or output amount is remaining to be swapped in/out")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"feePips")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint24"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The fee taken from the input amount, expressed in hundredths of a bip")))),(0,i.kt)("h4",{id:"return-values"},"Return Values:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"sqrtRatioNextX96")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint160"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The price after swapping the amount in/out, not to exceed the price target")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"amountIn")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The amount to be swapped in, of either token0 or token1, based on the direction of the swap")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"amountOut")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The amount to be received, of either token0 or token1, based on the direction of the swap")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"feeAmount")),(0,i.kt)("td",{parentName:"tr",align:"left"},"uint256"),(0,i.kt)("td",{parentName:"tr",align:"left"},"The amount of input that will be taken as a fee")))))}m.isMDXComponent=!0},3905:function(t,e,n){"use strict";n.d(e,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?i(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function p(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},i=Object.keys(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)n=i[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var l=r.createContext({}),u=function(t){var e=r.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},c=function(t){var e=u(t.components);return r.createElement(l.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},s=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,i=t.originalType,l=t.parentName,c=p(t,["components","mdxType","originalType","parentName"]),s=u(n),d=a,f=s["".concat(l,".").concat(d)]||s[d]||m[d]||i;return n?r.createElement(f,o(o({ref:e},c),{},{components:n})):r.createElement(f,o({ref:e},c))}));function d(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var i=n.length,o=new Array(i);o[0]=s;var p={};for(var l in e)hasOwnProperty.call(e,l)&&(p[l]=e[l]);p.originalType=t,p.mdxType="string"==typeof t?t:a,o[1]=p;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}s.displayName="MDXCreateElement"}}]);