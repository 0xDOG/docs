(self.webpackChunkuniswap=self.webpackChunkuniswap||[]).push([[5741],{4856:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return a},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return h}});var i=n(2122),r=n(9756),o=(n(7294),n(3905)),a={id:"fetching-prices",title:"Fetching Spot Prices"},s=void 0,p={unversionedId:"guides/fetching-prices",id:"version-3.0.0/guides/fetching-prices",isDocsHomePage:!1,title:"Fetching Spot Prices",description:"Fetching Token Prices with the SDK",source:"@site/SDK_versioned_docs/version-3.0.0/guides/04-fetching-prices.md",sourceDirName:"guides",slug:"/guides/fetching-prices",permalink:"/sdk/guides/fetching-prices",version:"3.0.0",sidebarPosition:4,frontMatter:{id:"fetching-prices",title:"Fetching Spot Prices"},sidebar:"version-V3/sdksidebar",previous:{title:"Creating a Trade",permalink:"/sdk/guides/creating-a-trade"},next:{title:"Pool",permalink:"/sdk/reference/classes/Pool"}},c=[{value:"Fetching Token Prices with the SDK",id:"fetching-token-prices-with-the-sdk",children:[{value:"Calling the functions",id:"calling-the-functions",children:[]},{value:"Understanding sqrtPrice",id:"understanding-sqrtprice",children:[]},{value:"token0Price",id:"token0price",children:[]},{value:"token1Price",id:"token1price",children:[]}]}],l={toc:c};function h(e){var t=e.components,n=(0,r.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,i.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"fetching-token-prices-with-the-sdk"},"Fetching Token Prices with the SDK"),(0,o.kt)("p",null,"This guide will teach you how to fetch the current market price of any token on Uniswap. First, you will learn how to call the getter methods ",(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price")," exposed on ",(0,o.kt)("inlineCode",{parentName:"p"},"Pool")," instances. Then you will peek under the hood and learn how the SDK calculates these quantities from the ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," value. Going through these calculations will hopefully provide the necessary context behind fixed-point numbers, square roots, and difficult-to-understand variable names like ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96"),". :)"),(0,o.kt)("h3",{id:"calling-the-functions"},"Calling the functions"),(0,o.kt)("p",null,"Similar to other examples, you first must set up your pool. If you\u2019re unsure how to collect all the parameters necessary in creating a ",(0,o.kt)("inlineCode",{parentName:"p"},"Pool")," instance see ",(0,o.kt)("a",{parentName:"p",href:"https://docs.uniswap.org/sdk/guides/creating-a-pool"},"Creating a Pool Instance")," or look at this typescript ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Uniswap/uniswap-docs/blob/main/sdk-examples/AddAndRemoveLiquidity.tsx"},"example"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"Pool")," class contains two getter methods ",(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price")," which will return the prices of each token respectively as a ",(0,o.kt)("inlineCode",{parentName:"p"},"Price"),"."),(0,o.kt)("p",null,"After constructing the pool, you can save the token prices as constants:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  const DAI_USDC_POOL = new Pool(\n    DAI,\n    USDC,\n    immutables.fee,\n    state.sqrtPriceX96.toString(),\n    state.liquidity.toString(),\n    state.tick\n  )\n  \n  const token0Price =  DAI_USDC_POOL.token0Price\n  const token1Price = DAI_USDC_POOL.token1Price\n")),(0,o.kt)("h3",{id:"understanding-sqrtprice"},"Understanding sqrtPrice"),(0,o.kt)("p",null,"What is ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96"),"?"),(0,o.kt)("p",null,"In Uniswap V3, prices of tokens are stored in the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.uniswap.org/protocol/reference/core/interfaces/pool/IUniswapV3PoolState#slot0"},"0th slot")," of the pool state. Storing the price values instead of deriving them allows pools to perform higher precision operations. In the actual implementation, prices are stored as square roots, hence the ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrt")," prefix. The price is stored as a square root because of the geometric nature of the core AMM algorithm, x*y=k. Essentially, the ",(0,o.kt)("a",{parentName:"p",href:"https://uniswap.org/whitepaper-v3.pdf"},"math")," works out well when working with the square root of the price. "),(0,o.kt)("p",null,"In addition, you'll notice the ",(0,o.kt)("inlineCode",{parentName:"p"},"X96")," suffix at the end of the variable name. This ",(0,o.kt)("inlineCode",{parentName:"p"},"X*")," naming convention is used throughout the Uniswap V3 codebase to indicate values that are encoded as binary ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Fixed-point_arithmetic"},"fixed-point numbers"),". Fixed-point is excellent at representing fractions while maintaining consistent fidelity and high precision in integer-only environments like the EVM, making it a perfect fit for representing prices, which of course are ultimately fractions. The number after ",(0,o.kt)("inlineCode",{parentName:"p"},"X")," indicates the number of ",(0,o.kt)("em",{parentName:"p"},"fraction bits")," - 96 in this case - reserved for encoding the value after the decimal point. The number of integer bits can be trivially derived from the size of the variable and the number of fraction bits. In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," is stored as a ",(0,o.kt)("inlineCode",{parentName:"p"},"uint160"),", meaning that there are ",(0,o.kt)("inlineCode",{parentName:"p"},"160 - 96 = 64")," integer bits."),(0,o.kt)("p",null,"Consider the following derivation, which formalizes the definitions above:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"sqrtPriceX96 = sqrt(price) * 2 ** 96\n")),(0,o.kt)("p",null,"Thus, to get a ",(0,o.kt)("inlineCode",{parentName:"p"},"price")," from a ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96")," value, you can execute the following operations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"sqrtPriceX96 = sqrt(price) * 2 ** 96\n# divide both sides by 2 ** 96\nsqrtPriceX96 / (2 ** 96) = sqrt(price)\n# square both sides\n(sqrtPriceX96 / (2 ** 96)) ** 2 = price\n# expand the squared fraction\n(sqrtPriceX96 ** 2) / ((2 ** 96) ** 2)  = price\n# multiply the exponents in the denominator to get the final expression\nsqrtRatioX96 ** 2 / 2 ** 192 = price\n")),(0,o.kt)("p",null,"You will see that the formula in the last step is how the SDK calculates the prices with the functions ",(0,o.kt)("a",{parentName:"p",href:"#token0price"},(0,o.kt)("inlineCode",{parentName:"a"},"token0Price"))," and ",(0,o.kt)("a",{parentName:"p",href:"#token1price"},(0,o.kt)("inlineCode",{parentName:"a"},"token1Price")),"."),(0,o.kt)("h3",{id:"token0price"},"token0Price"),(0,o.kt)("p",null,"Let's apply the math derived above to the functions ",(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price"),". Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtRatioX96")," is interchangeable with ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96"),". "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  /**\n   * Returns the current mid-price of the pool in terms of token0, i.e. the ratio of token1 over token0\n   */\n  public get token0Price(): Price<Token, Token> {\n    return (\n      this._token0Price ??\n      (this._token0Price = new Price(\n        this.token0,\n        this.token1,\n        Q192,\n        JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96)\n      ))\n    )\n  }\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," returns a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Price")," as the ratio of token1 over token0. Note that a ",(0,o.kt)("inlineCode",{parentName:"p"},"Price")," is constructed by:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"constructor(\n    baseToken: Token, \n    quoteToken: Token,\n    denominator: BigintIsh, \n    numerator: BigintIsh)\n")),(0,o.kt)("p",null,"Let's break down the denominator and the numerator of the returned price and prove that it matches the math derived above. Recall that the expression achieved above is "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"price = sqrtRatioX96 ** 2 / 2 ** 192\n")),(0,o.kt)("h4",{id:"the-numerator"},"The numerator"),(0,o.kt)("p",null,"It's worth noting that the numerator is misleadingly listed ",(0,o.kt)("em",{parentName:"p"},"below")," the denominator in the constructor for a ",(0,o.kt)("inlineCode",{parentName:"p"},"Price"),". In any case, you will see that the numerator of the fraction is ",(0,o.kt)("inlineCode",{parentName:"p"},"JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96)")," which nicely follows the math above: ",(0,o.kt)("inlineCode",{parentName:"p"},"sqrtPriceX96 ** 2"),". "),(0,o.kt)("h4",{id:"the-denominator"},"The denominator"),(0,o.kt)("p",null,"The denominator is ",(0,o.kt)("inlineCode",{parentName:"p"},"Q192"),". To break this number down recall the following constants defined in the SDK:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export const Q96 = JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(96))\nexport const Q192 = JSBI.exponentiate(Q96, JSBI.BigInt(2))\n")),(0,o.kt)("p",null,"Thus, the denominator for the ",(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," also matches the math derived above where ",(0,o.kt)("inlineCode",{parentName:"p"},"Q192")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"(2 ** 96) * (2 ** 96)")," which is the same as ",(0,o.kt)("inlineCode",{parentName:"p"},"(2 ** 192)"),"."),(0,o.kt)("h3",{id:"token1price"},"token1Price"),(0,o.kt)("p",null,"Recall that ",(0,o.kt)("inlineCode",{parentName:"p"},"token0Price")," is the ratio of token1 over token0 and that ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price")," is the ratio of token0 over token1. This means that the derivation for ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price")," follows the same math except the numerator and denominator are flipped, implying the inverse. "),(0,o.kt)("p",null,"So instead of "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"price = sqrtRatioX96 ** 2 / 2 ** 192\n")),(0,o.kt)("p",null," you have"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"}," price =  2 ** 192 / sqrtRatioX96 ** 2\n")),(0,o.kt)("p",null,"which is simply shown below in the function definition of ",(0,o.kt)("inlineCode",{parentName:"p"},"token1Price")," :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"  /**\n   * Returns the current mid-price of the pool in terms of token1, i.e. the ratio of token0 over token1\n   */\n  public get token1Price(): Price<Token, Token> {\n    return (\n      this._token1Price ??\n      (this._token1Price = new Price(\n        this.token1,\n        this.token0,\n        JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96),\n        Q192\n      ))\n    )\n  }\n")),(0,o.kt)("p",null," You can see that in the function definition the numerator is now ",(0,o.kt)("inlineCode",{parentName:"p"},"Q192")," and the denominator is now ",(0,o.kt)("inlineCode",{parentName:"p"},"JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96)"),", matching the expression above."))}h.isMDXComponent=!0},3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return l},kt:function(){return d}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=i.createContext({}),c=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=c(e.components);return i.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,k=u["".concat(p,".").concat(d)]||u[d]||h[d]||o;return n?i.createElement(k,a(a({ref:t},l),{},{components:n})):i.createElement(k,a({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);